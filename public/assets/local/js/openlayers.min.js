/**
 * OpenLayers Map Module
 * This module will initialize map from the given parameter
 *
 * @author			Aby Dahana
 * @profile			abydahana.github.io
 */
 
"use strict";

/**
 * Set default map center and zoom
 * This variable also used to format the map dynamically
 */
var _this,
	map,
	sourceVector,
	layerVector,
	bounds,
	lngLat,
	draggable_marker,
	colorscheme,
	geocoder,
	geolocation,
	apply_to,
	apply_address,
	drawingManager,
	geojson,
	loaded_markers							= [],
	loaded_polygons							= [],
	loaded_linestrings						= [],
	features								= [],
	polygons								= [],
	linestrings								= [],
	markers									= [],
	popup									= [];


var openlayers								= (function()
{
	return {
		/**
		 * render the map
		 */
		render: function(_this_)
		{
			this.reset();
			
			/* keep the "this" context */
			_this							= _this_,
			apply_to						= _this.attr('data-apply-coordinate-to'),
			apply_address					= _this.attr('data-apply-address-to'),
			leave_page						= false,
			
			/* set the coordinate from data-coordinate attribute*/
			lngLat							= (_this.attr('data-coordinate') ? JSON.parse(_this.attr('data-coordinate')) : ''),
			colorscheme						= (typeof lngLat.colorscheme !== 'undefined' ? lngLat.colorscheme : '#ff0000'),
			lngLat							= (lngLat && typeof lngLat.lng !== 'undefined' && typeof lngLat.lat !== 'undefined' ? [JSON.parse(lngLat.lng), JSON.parse(lngLat.lat)] : [107.0680127, -6.2299611]);
			
			if(!_this.attr('id'))
			{
				_this.attr('id', 'maps')
			}
			
			if(map)
			{
				map.dispose()
			}
			
			/* define and render map */
			map								= new ol.Map
			({
				interactions: ol.interaction.defaults
				({
					mouseWheelZoom: (0 == _this.attr('data-mousewheel') ? false : true)
				}),
				target: _this.attr('id'),
				layers:
				[
					new ol.layer.Tile
					({
						source: new ol.source.OSM
						({
							/* Google Maps will be used, comment the url and attributions to rollback the default */
							url: 'https://mt{0-3}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
							attributions:
							[
								'© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.',
								'Tiles by <a href="https://developers.google.com/maps/terms" target="_blank">© Google</a>'
							]
						})
					})
				],
				view: new ol.View
				({
					center: ol.proj.transform(lngLat, 'EPSG:4326', 'EPSG:3857'), /* bekasi */
					zoom: (_this.attr('data-zoom') ? parseInt(_this.attr('data-zoom')) : 12),
					maxZoom: 18
				}),
				loadTilesWhileAnimating: true,
				loadTilesWhileInteracting: true
			});
			
			if(0 == _this.attr('data-mousewheel'))
			{
				/* create ctrl+wheel event to zoom the map */
				var mouseWheeZoom			= new ol.interaction.MouseWheelZoom();
				map.addInteraction(mouseWheeZoom),
				map.on('wheel', function(evt)
				{
					mouseWheeZoom.setActive(ol.events.condition.platformModifierKeyOnly(evt))
				});
			}
			
			/* on property change */
			map.getView().on('propertychange', function(event)
			{
				if(typeof geolocation !== 'undefined')
				{
					/* stop tracking to prevent map flicker */
					geolocation.setTracking(false)
				}
			}),
			
			/* on pointermove */
			map.on('pointermove', function(e)
			{
				var pixel					= map.getEventPixel(e.originalEvent),
					hit						= map.hasFeatureAtPixel(pixel);
				map.getViewport().style.cursor = hit ? 'pointer' : '';
			}),
			
			/* update map size */
			map.updateSize();
			
			(1 == _this.attr('data-geocoder') ? this.geocoder() : ''),
			
			(1 == _this.attr('data-geolocation') ? this.geolocation() : '');
			
			/* load drawing manager */
			if(1 == _this.attr('data-drawing-manager'))
			{
				this.drawingManager()
			}
			else if(_this.attr('data-polygon') || _this.attr('data-linestring'))
			{
			}
			
			/* load marker */
			else
			{
				this.marker(null, null, null, null, _this.attr('data-draggable'))
			}
			
			/* load data from json file */
			if(_this.attr('data-url'))
			{
				/* serialize and build data */
				this.loadJson(_this.attr('data-url'), this)
			}
			else
			{
				/* build polygon from predefined data */
				(_this.attr('data-polygon') ? this.polygon(JSON.parse(_this.attr('data-polygon')), true) : ''),
				
				/* build linestring from predefined data */
				(_this.attr('data-linestring') ? this.linestring(JSON.parse(_this.attr('data-linestring')), true) : ''),
				
				/* build marker from predefined data */
				(_this.attr('data-marker') ? this.marker(JSON.parse(_this.attr('data-marker')), true) : '')
			}
		},
		
		reset: function()
		{
			if(markers)
			{
				$.each(markers, function(key, val)
				{
					if(drawingManager)
					{
						val.setMap(null)
					}
					else
					{
						if(val.getVisible())
						{
							val.setVisible(false)
						}
						else
						{
							val.setVisible(false)
						}
					}
				})
			}
			
			if(polygons)
			{
				$.each(polygons, function(key, val)
				{
					if(drawingManager)
					{
						val.setMap(null)
					}
					else
					{
						if(val.getVisible())
						{
							val.setVisible(false)
						}
						else
						{
							val.setVisible(false)
						}
					}
				})
			}
			
			if(linestrings)
			{
				$.each(linestrings, function(key, val)
				{
					if(drawingManager)
					{
						val.setMap(null)
					}
					else
					{
						if(val.getVisible())
						{
							val.setVisible(false)
						}
						else
						{
							val.setVisible(false)
						}
					}
				})
			}
			
			loaded_markers					= [],
			loaded_polygons					= [],
			loaded_linestrings				= [],
			features						= [],
			polygons						= [],
			linestrings						= [],
			markers							= [],
			bounds							= []/*new google.maps.LatLngBounds()*/;
		},
		
		loadJson: function(url, _this, boundTo)
		{
			/* load the data from URL (json file */
			$.ajax
			({
				url: url,
				method: 'POST',
				dataType: 'JSON',
				contentType: false,
				processData: false
			})
			.done(function(response)
			{
				if(response)
				{
					/* serialize and build data */
					$.each(response, function(key, val)
					{
						if(typeof val.features !== 'undefined' && typeof val.features[0] !== 'undefined' && val.features[0].geometry !== 'undefined' && val.features[0].geometry.type !== 'undefined' && (val.features[0].geometry.type.toLowerCase() == 'polygon' || val.features[0].geometry.type.toLowerCase() == 'multipolygon'))
						{
							_this.polygon(val, (!key ? true : false), key, 'polygon')
						}
						else if(typeof val.features !== 'undefined' && typeof val.features[0] !== 'undefined' && val.features[0].geometry !== 'undefined' && val.features[0].geometry.type !== 'undefined' && (val.features[0].geometry.type.toLowerCase() == 'linestring' || val.features[0].geometry.type.toLowerCase() == 'multilinestring'))
						{
							_this.linestring(val, (!key ? true : false), key, 'polygon')
						}
						else if(typeof val.features !== 'undefined' && typeof val.features[0] !== 'undefined' && val.features[0].geometry !== 'undefined' && val.features[0].geometry.coordinate !== 'undefined')
						{
							_this.marker(val, (!key ? true : false), key, 'polygon')
						}
					})
				}
			})
		},
		
		drawingManager: function()
		{
			var coordinates					= [],
				layerVector					= new ol.layer.Vector
				({
					source: new ol.source.Vector(),
					style: new ol.style.Style
					({
						stroke: new ol.style.Stroke
						({
							color: colorscheme,
							width: 2
						}),
						fill: new ol.style.Fill
						({
							color: hex_to_rgba(colorscheme, .35)
						})
					})
				});
			
			drawingManager					= new ol.interaction.Draw
			({
				type: ('polygon' == _this.attr('data-drawing-type') ? 'Polygon' : 'LineString'),
				source: layerVector.getSource()
			});
			
			map.addLayer(layerVector),
			
			map.addInteraction(drawingManager),
			
			map.addInteraction(new ol.interaction.Snap({source: layerVector.getSource()})),
			
			map.addInteraction(new ol.interaction.Modify({source: layerVector.getSource()})),
			
			drawingManager.on('drawend', function(event)
			{
				var key						= (features.length ? parseInt(features.length + 1) : 0),
					prepare					= [];
				features[key]				= event.feature.getGeometry().getCoordinates();
				
				$.each(features, function(_key, _val)
				{
					if(!_val) return;
					
					var coord				= [],
						_val				= ('polygon' == _this.attr('data-drawing-type') ? _val[0] : _val);
					$.each(_val, function(__key, __val)
					{
						coord.push(ol.proj.transform(__val, 'EPSG:3857', 'EPSG:4326'))
					}),
					prepare.push
					({
						type: 'Feature',
						geometry:
						{
							type: ('polygon' == _this.attr('data-drawing-type') ? 'Polygon' : 'LineString'),
							coordinates: ('polygon' == _this.attr('data-drawing-type') ? [coord] : coord)
						},
						properties:
						{
						}
					})
				}),
				
				$(apply_to).val
				(
					JSON.stringify
					({
						colorscheme: colorscheme,
						features: prepare,
						measure: (Math.round(('polygon' == _this.attr('data-drawing-type') ? event.feature.getGeometry().getArea() : event.feature.getGeometry().getLength()) * 100) / 100)
					})
				);
				
				var modify					= new ol.interaction.Modify
				({
					source: layerVector.getSource()
				});
				
				map.addInteraction(modify),
				
				modify.on('modifyend', function(event)
				{
					features[key]			= event.features.getArray()[0].getGeometry().getCoordinates();
					var prepare				= [];
					$.each(features, function(_key, _val)
					{
						var coord			= [],
							_val			= ('polygon' == _this.attr('data-drawing-type') ? _val[0] : _val);
						
						$.each(_val, function(__key, __val)
						{
							coord.push(ol.proj.transform(__val, 'EPSG:3857', 'EPSG:4326'))
						}),
						prepare.push
						({
							type: 'Feature',
							geometry:
							{
								type: ('polygon' == _this.attr('data-drawing-type') ? 'Polygon' : 'LineString'),
								coordinates: ('polygon' == _this.attr('data-drawing-type') ? [coord] : coord)
							},
							properties:
							{
							}
						})
					}),
					
					$(apply_to).val
					(
						JSON.stringify
						({
							colorscheme: (event.features.getArray()[0].getStyle() ? '#' + rgba_to_hex(('polygon' == _this.attr('data-drawing-type') ? event.features.getArray()[0].getStyle().getFill().getColor() : event.features.getArray()[0].getStyle().getStroke().getColor())) : colorscheme),
							features: prepare,
							measure: (Math.round(('polygon' == _this.attr('data-drawing-type') ? event.features.getArray()[0].getGeometry().getArea() : event.features.getArray()[0].getGeometry().getLength()) * 100) / 100)
						})
					)
				})
			})
		},
		
		/**
		 * Add marker
		 */
		marker: function(shapes, boundTo, indexID, groupID, draggable)
		{
			/* Draw linestring from array coordinate */
			if(shapes && typeof shapes.coordinate !== 'undefined')
			{
				if(loaded_markers && $.inArray(indexID, loaded_markers) === -1)
				{
					layerVector				= new ol.layer.Vector
					({
						source: new ol.source.Vector
						({
							features:
							[
								new ol.Feature
								({
									type: 'click',
									title: (typeof shapes.title !== 'undefined' ? shapes.title : ''),
									description: (typeof shapes.description !== 'undefined' ? shapes.description : ''),
									geometry: new ol.geom.Point(ol.proj.fromLonLat([shapes.coordinate.lng, shapes.coordinate.lat]))
								})
							]
						}),
						style: new ol.style.Style
						({
							image: new ol.style.Icon
							({
								scale: 1.2,
								src: (shapes.icon ? shapes.icon : (typeof shapes.coordinate.colorscheme !== 'undefined' ? '//chart.apis.google.com/chart?chst=d_map_pin_letter&chld=•|' + shapes.coordinate.colorscheme.replace('#', '') : config.asset_url + 'openlayers/resources/icons/marker.png'))
							})
						}),
						id: (indexID + 1),
						group: 'marker_' + groupID
					});
					
					map.addLayer(layerVector),
					
					markers.push(layerVector),
					
					loaded_markers.push(indexID)
				}
			}
			else if(shapes && typeof shapes === 'object')
			{
				$.each(shapes, function(key, val)
				{
					if(typeof val.coordinate !== 'undefined' && $.inArray(indexID, loaded_markers) === -1)
					{
						layerVector			= new ol.layer.Vector
						({
							source: new ol.source.Vector
							({
								features:
								[
									new ol.Feature
									({
										type: 'click',
										title: (typeof val.title !== 'undefined' ? '<label class="d-block font-weight-bold text-muted mb-0">' + val.title + '</label>' : ''),
										description: (typeof val.description !== 'undefined' ? '<p class="mb-0">' + val.description + '</p>' : ''),
										geometry: new ol.geom.Point(ol.proj.fromLonLat([val.coordinate.lng, val.coordinate.lat]))
									})
								]
							}),
							style: new ol.style.Style
							({
								image: new ol.style.Icon
								({
									scale: 1.2,
									src: (val.icon ? val.icon : (typeof val.coordinate.colorscheme !== 'undefined' ? '//chart.apis.google.com/chart?chst=d_map_pin_letter&chld=•|' + val.coordinate.colorscheme.replace('#', '') : config.asset_url + 'openlayers/resources/icons/marker.png'))
								})
							}),
							id: (indexID),
							group: 'marker_' + groupID
						});
						
						map.addLayer(layerVector),
						
						markers.push(layerVector),
						
						loaded_markers.push(indexID)
					}
				})
			}
			
			layerVector						= new ol.layer.Vector
			({
				source: new ol.source.Vector
				({
					features:
					[
						new ol.Feature
						({
							type: 'click',
							title: '<label class="d-block font-weight-bold text-muted mb-0">' + phrase.default_marker + '</label>',
							description: '<p class="mb-0">' + phrase.this_can_be_drag_on_edit_mode + '</p>',
							geometry: new ol.geom.Point(map.getView().getCenter())
						})
					]
				}),
				style: new ol.style.Style
				({
					image: new ol.style.Icon
					({
						scale: .4,
						src: config.asset_url + 'openlayers/resources/icons/marker.png'
					})
				})
			});
			
			map.addLayer(layerVector),
			
			markers.push(layerVector),
			
			$.each(markers, function(key, val)
			{
				popup						= new ol.Overlay.Popup();
				
				map.addOverlay(popup),
				
				map.on('click', function(event)
				{
					var point				= map.forEachFeatureAtPixel
					(
						event.pixel,
						function(ft, layer)
						{
							return ft
						}
					);
					
					/* check if it clicked on marker */
					if(point && point.get('type') == 'click' && (point.get('title') || point.get('description')))
					{
						var geometry		= point.getGeometry();
						
						popup.show(geometry.getCoordinates(), point.get('title') + point.get('description'))
					}
					else
					{
						popup.hide()
					}
				})
			}),
			
			(boundTo && polygons.length > 0 ? map.getView().fit(layerVector.getSource().getExtent(), {size: map.getSize()}) : null);
			
			if(draggable)
			{
				/* make the default marker to be draggable */
				var draggableMarker			= new ol.interaction.Translate
				({
					features: new ol.Collection(layerVector.getSource().getFeatures())
				});
				
				/* add interaction */
				map.addInteraction(draggableMarker),
				
				/* add dragend event */
				draggableMarker.on('translateend', function(event)
				{
					/* dragend event */
					if(typeof geolocation !== 'undefined')
					{
						geolocation.setTracking(false)
					}
					
					var coordinate			= ol.proj.transform(event.coordinate, 'EPSG:3857', 'EPSG:4326'),
						coordinate			=
						{
							lat: coordinate[1],
							lng: coordinate[0],
							colorscheme: colorscheme
						};
					
					$(apply_to).val(JSON.stringify(coordinate)),
					
					/* getting the address name */
					$.get('https://nominatim.openstreetmap.org/reverse?accept-language=id&format=json&lat=' + coordinate.lat + '&lon=' + coordinate.lng + '&zoom=18&addressdetails=1', function(response)
					{
						/* apply to inputs */
						$(apply_address).val(response.display_name).trigger('change'),
						
						$('#gcd-input-query').val(response.display_name)
					})
				})
			}
		},
		
		polygon: function(shapes, boundTo, indexID, groupID)
		{
			/* Draw polygon from array coordinate */
			if(shapes && typeof shapes.features !== 'undefined')
			{
				if(!indexID)
				{
					var indexID				= 0;
				}
				
				/* serialize and build path */
				$.each(shapes.features, function(key, val)
				{
					if(!val || typeof val !== 'object')
					{
						return;
					}
					
					var path				= [],
						multipath			= [];
					
					if(!val || typeof val.geometry == 'undefined' || typeof val.geometry.coordinates == 'undefined')
					{
						return;
					}
					
					$.each(val.geometry.coordinates, function(_key, _val)
					{
						if(typeof _val[0][0] !== 'undefined')
						{
							$.each(_val, function(__key, __val)
							{
								path.push(ol.proj.fromLonLat(__val))
							})
						}
						else
						{
							path.push(ol.proj.fromLonLat(_val))
						}
					});
					
					/* Show polygon in the map */
					if(loaded_polygons && $.inArray(indexID, loaded_polygons) === -1)
					{
						layerVector			= new ol.layer.Vector
						({
							source: new ol.source.Vector
							({
								features:
								[
									new ol.Feature
									({
										type: 'click',
										title: (typeof shapes.title !== 'undefined' ? '<label class="d-block font-weight-bold text-muted mb-0">' + shapes.title + '</label>' : ''),
										description: (typeof shapes.description !== 'undefined' ? '<p class="mb-0">' + shapes.description + '</p>' : ''),
										geometry: new ol.geom.Polygon([path])
									})
								]
							}),
							style: new ol.style.Style
							({
								stroke: new ol.style.Stroke
								({
									color: (typeof shapes.colorscheme !== 'undefined' ? shapes.colorscheme : '#FF0000'),
									width: 2
								}),
								fill: new ol.style.Fill
								({
									color: hex_to_rgba((typeof shapes.colorscheme !== 'undefined' ? shapes.colorscheme : '#FF0000'), .35)
								})
							}),
							id: indexID,
							group: 'polygon_' + groupID
						});
						
						map.addLayer(layerVector),
						
						polygons.push(layerVector),
						
						loaded_polygons.push(indexID);
						
						indexID++;
					}
				}),
			
				$.each(polygons, function(key, val)
				{
					features[key]			= val.getSource().getFeatures()[0].getGeometry().getCoordinates();
					popup					= new ol.Overlay.Popup();
					
					map.addOverlay(popup),
					
					map.on('click', function(event)
					{
						var point			= map.forEachFeatureAtPixel
						(
							event.pixel,
							function(ft, layer)
							{
								return ft
							}
						);
						
						/* check if it clicked on polygon */
						if(point && point.get('type') == 'click' && (point.get('title') || point.get('description')))
						{
							var geometry	= point.getGeometry();
							popup.show(geometry.flatCoordinates, point.get('title') + point.get('description'))
						}
						else
						{
							popup.hide()
						}
					});
					
					if(drawingManager)
					{
						var modify			= new ol.interaction.Modify
						({
							source: val.getSource()
						});
						
						map.addInteraction(modify),
						
						modify.on('modifyend', function(event)
						{
							features[key]	= event.features.getArray()[0].getGeometry().getCoordinates();
							var prepare		= [];
							$.each(features, function(_key, _val)
							{
								if(!_val) return;
								
								var coord	= [];
								$.each(_val[0], function(__key, __val)
								{
									coord.push(ol.proj.transform(__val, 'EPSG:3857', 'EPSG:4326'))
								}),
								prepare.push
								({
									type: 'Feature',
									geometry:
									{
										type: 'Polygon',
										coordinates: [coord]
									},
									properties:
									{
									}
								})
							}),
							$(apply_to).val
							(
								JSON.stringify
								({
									colorscheme: '#' + rgba_to_hex(val.getStyle().getFill().getColor()),
									features: prepare,
									measure: (Math.round(val.getSource().getFeatures()[0].getGeometry().getArea() * 100) / 100)
								})
							)
						})
					}
				}),
				
				(boundTo && polygons.length > 0 ? map.getView().fit(layerVector.getSource().getExtent(), {size: map.getSize()}) : null)
			}
		},
		
		linestring: function(shapes, boundTo, indexID, groupID)
		{
			/* Draw polygon from array coordinate */
			if(shapes && typeof shapes.features !== 'undefined')
			{
				if(!indexID)
				{
					var indexID				= 0;
				}
				
				/* serialize and build path */
				$.each(shapes.features, function(key, val)
				{
					if(!val || typeof val !== 'object')
					{
						return;
					}
					
					var path				= [],
						multipath			= [];
					
					if(!val || typeof val.geometry == 'undefined' || typeof val.geometry.coordinates == 'undefined')
					{
						return;
					}
					
					features.push(val),
					
					$.each(val.geometry.coordinates, function(_key, _val)
					{
						if(typeof _val[0][0] !== 'undefined')
						{
							$.each(_val, function(__key, __val)
							{
								path.push(ol.proj.fromLonLat(__val))
							})
						}
						else
						{
							path.push(ol.proj.fromLonLat(_val))
						}
					});
					
					/* Show polygon in the map */
					if(loaded_linestrings && $.inArray(indexID, loaded_linestrings) === -1)
					{
						layerVector			= new ol.layer.Vector
						({
							source: new ol.source.Vector
							({
								features:
								[
									new ol.Feature
									({
										type: 'click',
										title: (typeof shapes.title !== 'undefined' ? '<label class="d-block font-weight-bold text-muted mb-0">' + shapes.title + '</label>' : ''),
										description: (typeof shapes.description !== 'undefined' ? '<p class="mb-0">' + shapes.description + '</p>' : ''),
										geometry: new ol.geom.LineString(path)
									})
								]
							}),
							style: new ol.style.Style
							({
								stroke: new ol.style.Stroke
								({
									color: (typeof shapes.colorscheme !== 'undefined' ? shapes.colorscheme : '#FF0000'),
									width: 6
								})
							}),
							id: indexID,
							group: 'linestring_' + groupID
						});
						
						map.addLayer(layerVector),
						
						(drawingManager ? map.addInteraction(new ol.interaction.Modify({source: layerVector.getSource()})) : ''),
						
						linestrings.push(layerVector),
						
						loaded_linestrings.push(indexID);
						
						indexID++;
					}
				}),
			
				$.each(linestrings, function(key, val)
				{
					features[key]			= val.getSource().getFeatures()[0].getGeometry().getCoordinates();
					popup					= new ol.Overlay.Popup();
					
					map.addOverlay(popup),
					
					map.on('click', function(event)
					{
						var point			= map.forEachFeatureAtPixel
						(
							event.pixel,
							function(ft, layer)
							{
								return ft
							}
						);
						
						/* check if it clicked on polygon */
						if(point && point.get('type') == 'click' && (point.get('title') || point.get('description')))
						{
							var geometry	= point.getGeometry();
							popup.show(geometry.flatCoordinates, point.get('title') + point.get('description'))
						}
						else
						{
							popup.hide()
						}
					});
					
					if(drawingManager)
					{
						var modify			= new ol.interaction.Modify
						({
							source: val.getSource()
						});
						
						map.addInteraction(modify),
						
						modify.on('modifyend', function(event)
						{
							features[key]	= event.features.getArray()[0].getGeometry().getCoordinates();
							var prepare		= [];
							$.each(features, function(_key, _val)
							{
								if(!_val) return;
								
								var coord	= [];
								$.each(_val, function(__key, __val)
								{
									coord.push(ol.proj.transform(__val, 'EPSG:3857', 'EPSG:4326'))
								}),
								prepare.push
								({
									type: 'Feature',
									geometry:
									{
										type: 'LineString',
										coordinates: coord
									},
									properties:
									{
									}
								})
							}),
							
							$(apply_to).val
							(
								JSON.stringify
								({
									colorscheme: rgba_to_hex(val.getStyle().getStroke().getColor()),
									features: prepare,
									measure: (Math.round(val.getSource().getFeatures()[0].getGeometry().getLength() * 100) / 100)
								})
							)
						})
					}
				}),
				
				(boundTo && polygons.length > 0 ? map.getView().fit(layerVector.getSource().getExtent(), {size: map.getSize()}) : null)
			}
		},
		
		/**
		 * Add geocoder to search places
		 */
		geocoder: function(_this)
		{
			geocoder						= new Geocoder
			(
				'nominatim',
				{
					provider: config.openlayers_search_provider, /* available provider: osm, mapquest (require key), photon, pelias(require key), bing(require key) and opencage(require key) */
					key: ('google' == config.openlayers_search_provider ? config.google_maps_api_key : config.openlayers_search_key), /* api key */
					targetType: 'text-input',
					countrycodes: 'id',
					placeholder: phrase.search_place,
					limit: 10,
					autoComplete: true,
					featureStyle: null
				}
			);
			
			/* add geocoder into map controls directories */
			map.addControl(geocoder);
			
			/* create event when address is chosen */
			geocoder.on('addresschosen', function(response)
			{
				if(typeof geolocation !== 'undefined')
				{
					geolocation.setTracking(false)
				}
				var coordinate				= ol.proj.transform(response.coordinate, 'EPSG:3857', 'EPSG:4326');
				var coordinate				=
				{
					lat: coordinate[1],
					lng: coordinate[0]
				};
				
				/* apply to inputs */
				$(_this.attr('data-apply-coordinate-to')).val(JSON.stringify(coordinate)),
				$(_this.attr('data-apply-address-to')).val(response.address.details.name).trigger('change'),
				
				$('#gcd-input-query').val(response.address.details.name),
				markers.setGeometry(new ol.geom.Point(response.coordinate)),
				map.getView().setCenter(response.coordinate),
				map.getView().setZoom(18)
			});
		},
		
		/**
		 * Add geolocation to detect device location
		 */
		geolocation: function()
		{
			geolocation						= new ol.Geolocation
			({
				projection: map.getView().getProjection(),
				tracking: true,
				trackingOptions:
				{
					enableHighAccuracy: true,
					maximumAge: 2000
				}
			});
			
			/* on device position change */
			geolocation.on('change', function()
			{
				var pos						= geolocation.getPosition();
				markers.setGeometry(new ol.geom.Point(pos)),
				map.getView().setCenter(pos),
				map.getView().setZoom(18)
			});
		},
		
		/**
		 * pulsate effect
		 */
		pulsate: function pulsate(feature, style, duration)
		{
			var start						= new Date().getTime(),
				key							= map.on('postcompose', function(event)
			{
				var vectorContext			= event.vectorContext,
					frameState				= event.frameState,
					flashGeom				= feature.getGeometry().clone(),
					elapsed					= frameState.time - start,
					elapsedRatio			= elapsed / duration,
					radius					= ol.easing.easeOut(elapsedRatio) * 35 + 6,
					opacity					= ol.easing.easeOut(1 - elapsedRatio),
					fillOpacity				= ol.easing.easeOut(0.3 - elapsedRatio);
					
				vectorContext.setStyle(new ol.style.Style
				({
					image: new ol.style.Circle
					({
						radius: radius,
						fill: new ol.style.Fill
						({
							color: 'rgba(255, 0, 0, ' + (fillOpacity) + ')'
						}),
						stroke: new ol.style.Stroke
						({
							color: 'rgba(255, 0, 0, ' + fillOpacity + ')',
							width: 1 + opacity
						})
					})
				})),
				vectorContext.drawGeometry(flashGeom),
				vectorContext.setStyle(style),
				vectorContext.drawGeometry(feature.getGeometry());
				
				if(elapsed > duration)
				{
					ol.Observable.unByKey(key);
					openlayers.pulsate(feature, style, duration);
				}
				
				map.render();
			})
		}
	}
})();
